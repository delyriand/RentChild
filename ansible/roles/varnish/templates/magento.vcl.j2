backend defaultbackend{
    .host = "{{ varnish_vcl_host }}";
    .port = "{{ varnish_vcl_port }}";
    .connect_timeout = {{ varnish_vcl_connect_timeout }};
    .first_byte_timeout = {{ varnish_vcl_first_byte_timeout }};
    .between_bytes_timeout = {{ varnish_vcl_between_bytes_timeout }};
}

# List of IPs allowed to access the admin interface
acl admin {
{% for acl_admin_ip in varnish_vcl_acl_admin_ips %}
    {{ acl_admin_ip }};
{% endfor %}
}

# List of IPs allowed to issue purge request by Ctrl-F5
acl purge {
{% for acl_purge_ip in varnish_vcl_acl_purge_ips %}
    {{ acl_purge_ip }};
{% endfor %}
}

#
# vcl_recv is called when a client request is received by Varnish
#
sub vcl_recv {

{% if varnish_magento_vcl_access_admin_only_acl_admin %}
    # The admin interface is only allowed to the IP belonging to the
    # access_admin interface.
    # But beware about the pattern "/admin" which is also tested in the
    # whole expression. It might filter some unwanted URL.
    # e.g.  FQDN/.../adminhtml/.../
    if (req.url ~ "/admin" && !client.ip ~ admin) {
        error 403 "Forbidden";
    }
{% endif %}

{% if varnish_magento_vcl_smile_magecache_module %}
    # Smile_MageCache - Varnish connection request handler
    if (req.http.X-Command && req.http.X-Secret == "{{ varnish_vcl_magento_secret }}") {
        if (req.http.X-Command == "Purge-By-Header") {
            if (req.http.X-Arg-Name && req.http.X-Arg-Value) {
                ban("obj.http." + req.http.X-Arg-Name + " ~ " + req.http.X-Arg-Value);
                error 200 "Done";
            } else {
                error 500 "Argument is missing";
            }
        } elsif (req.http.X-Command == "Purge-By-URL") {
            if (req.http.X-Arg-Pattern) {
                ban("req.url ~ " + req.http.X-Arg-Pattern);
                error 200 "Done";
            } else {
                error 500 "Argument is missing";
            }
        } else {
            error 500 "Unknown command";
        }
    }
{% endif %}

    # Our application does not manage other methods than HEAD, GET and POST
    # Warning : if you use REST webservices, add DELETE and PUT to this list
    if (req.request != "GET" &&
        req.request != "HEAD" &&
        req.request != "POST" ) {

        error 405 "Method not allowed.";
    }

    # Only GET and HEAD can be cached, so pass everything else directly
    # to the backend.
    if (req.request != "GET" &&
        req.request != "HEAD") {
        return (pass);
    }

    # By default everything goes to myfrontal backend
    set req.backend = defaultbackend;

    # Update the X-Forwarded-For header
    if (req.restarts == 0) {
      if (req.http.x-forwarded-for) {
          set req.http.X-Forwarded-For =
              req.http.X-Forwarded-For + ", " + client.ip;
      } else {
          set req.http.X-Forwarded-For = client.ip;
      }
    }

    # Never cache the load-balancer page needed to enable/disable the myfronts
    if  (req.http.host == "lbcheck") {
        return (pass);
    }

    # Do not check in the cache for AJAX requests, checkout and cart pages, etc...
    if (req.url ~ "^/(index.php/)?({% for url_exceptions in varnish_magento_vcl_url_exceptions %}{{ url_exceptions }}{% if not loop.last %}|{% endif %}{% endfor %})/") {
        set req.http.X-Magento-Uncacheable="y";
        return (pass);
    }

    # The grace period allow to serve cached entry after expiration while
    # a new version is being fetched from the backend
    set req.grace = 30s;

    # Each cache entry on Varnish is based on a key (provided by vcl_hash)
    # AND the Vary header. This header, sent by the server, define on which
    # client header the cache entry must vary. And for each different value of
    # the specified client header, a new cache entry on the same key will be created.
    #
    # In case of compression, the mod_deflate on the Apache backend will add
    # "Vary: Accept-Encoding", as some HTTP client does not support the compression
    # and some support only gzip, and some gzip and deflate. The last ones are the
    # majority but they do not advertise "gzip" and "deflate" in the same order. So to avoid
    # storing a different cache for "gzip,deflate" and "deflate,gzip", we turn the
    # accept-encoding into just "gzip".
    # We do not take into account "deflate" only browsers, as they have only a theorical
    # existence ;) Worst case: they will receive the uncompressed format.
    #
    # So at the end we would have only 2 versions for the same cache entry:
    #     - gziped
    #     - uncompressed
    if (req.http.Accept-Encoding) {
        if (req.http.Accept-Encoding ~ "gzip") {
          set req.http.Accept-Encoding = "gzip";
        } else {
            remove req.http.Accept-Encoding;
        }
    }

    # by default for all the rest, we try to serve from the cache
    return (lookup);
}

#
# vcl_fetch is executed when the response come back from the backend
#
sub vcl_fetch {
{% if varnish_magento_vcl_esi_enabled %}
    set beresp.do_esi = true;
{% endif %}
    # If we are serving a magento non-cacheable URL, terminate processing here
    # The object will not actually be cached
    # Process "X-Magento-Uncacheable" flag coming from application
    if (req.http.X-Magento-Uncacheable == "y" || beresp.http.X-Magento-Uncacheable == "y") {
        return(deliver);
    }

    set beresp.grace = 30s;

    # Do not cache 302 temporary redirect and 50x errors
    if (beresp.status == 302 || beresp.status >= 500) {
        return (hit_for_pass);
    }

{% if varnish_magento_vcl_smile_magecache_module %}
    # Define cache time depending on type, URL or status code
    if (beresp.status == 302 || beresp.status >= 500) {
        set beresp.ttl = 15s;
    } elsif (beresp.status == 404) {
        set beresp.ttl = 5m;
    } else {
        # Default for all other ressources, included pages.
        set beresp.ttl = 1d;
    }
{% else %}
    # Define cache time depending on type, URL or status code
    if (beresp.status == 301 || (beresp.status >=400 &&  beresp.status < 500)) {
        # Permanent redirections and client error cached for a short time
        set beresp.ttl = 120s;
    } elsif (req.url ~ "\.(gif|jpg|jpeg|bmp|png|tiff|tif|ico|img|tga|wmf)$") {
        set beresp.ttl = 1d;
    } elsif (req.url ~ "/skin/") {
        set beresp.ttl = 2h;
    } else {
        # Default for all other ressources, included pages.
        set beresp.ttl = 2400s;
    }
{% endif %}

    unset beresp.http.Set-Cookie;
    return (deliver);
}

#
# vcl_deliver is called when sending the response to the client.
# Some headers are added to help debug
#
sub vcl_deliver {
    if (obj.hits > 0) {
        set resp.http.X-Cache = "HIT";
        set resp.http.X-Cache-Hits = obj.hits;
    }
    else {
        set resp.http.X-Cache = "MISS";
    }
    # Set myfrontal ID
    set resp.http.X-Front = "defaultbackend";

    # Prevent disclosure
    unset resp.http.Via;
    unset resp.http.X-Powered-By;

    return (deliver);
}

# sub vcl_error {
#     set obj.http.Content-Type = "text/html; charset=utf-8";
#     set obj.http.Retry-After = "5";
#     synthetic {"
# <?xml version="1.0" encoding="utf-8"?>
# <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
#  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
# <html>
#   <head>
#     <title>"} + obj.status + " " + obj.response + {"</title>
#   </head>
#   <body>
#     <h1>Error "} + obj.status + " " + obj.response + {"</h1>
#     <p>"} + obj.response + {"</p>
#     <h3>Guru Meditation:</h3>
#     <p>XID: "} + req.xid + {"</p>
#     <hr>
#     <p>Varnish cache server</p>
#   </body>
# </html>
# "};
#     return (deliver);
# }



# Process Ctrl-F5 requests
sub vcl_hit {
    if (req.http.Cache-Control ~ "no-cache" && client.ip ~ purge) {
        purge;
        return(restart);
    }
}

sub vcl_miss {
    if (req.http.Cache-Control ~ "no-cache" && client.ip ~ admin) {
        purge;
    }
}

sub vcl_hash {
    hash_data(req.url);
    if (req.http.host) {
        hash_data(req.http.host);
    } else {
        hash_data(server.ip);
    }
{% if varnish_magento_vcl_specific_cookie %}
    if (req.http.cookie ~ "{{ varnish_magento_vcl_specific_cookie }}=") {
        set req.http.X-COOKIE = regsub(req.http.cookie, ".*{{ varnish_magento_vcl_specific_cookie }}=([^;]+);.*", "\1");
        hash_data(req.http.X-COOKIE);
        remove req.http.X-COOKIE;
    }
    return (hash);
{% endif %}
}
